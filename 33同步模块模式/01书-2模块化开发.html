<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
	</body>
	<script>
		//定义模块管理器单体对象
		var F = F || {};
		/***
		 *定义模块方法(理论上，模块方法应放在闭包中实现，可以隐蔽内部信息，
		 *这里我们为让读者能够看明白，我们忽略此步骤)
		 * @param str 模块路由
		 * @param fn 模块方法
		 **/
		F.define = function(str, fn) {
			//解析模块路由
			var parts = str.split('.'),
				// old当前模块的祖父模块，parent当前模块父模块
				//如果在闭包中，为了屏蔽对模块直接访问，建议将模块添加给闭包内部私有变量
				old = parent = this,
				//i模块层级,len 模块层级长度
				i = len = 0;
			//如果第一个模式是模块管理器单体对象，则移除
			if(parts[0] === 'F') {
				parts = parts.slice(1);
			}
			//屏蔽对define与module模块方法的重写
			if(parts[0] === 'define' || parts[0] === 'module') {
				return;
			}
			//遍历路由模块并定义每层模块
			for(len = parts.length; i < len; i++) {
				//如果父模块中不存在当前模块
				if(typeof parent[parts[i]] === 'undefined') {
					//声明当前模块
					parent[parts[i]] = {};
				}
				//缓存下一层级的祖父模块
				old = parent;
				//缓存下一层级父模块
				parent = parent[pars[i]];
			}
			//如果给定模块方法则定义该模块方法
			if(fn) {
				//此时i等于parts.length, 故减一
				old[parts[--i]] = fn();
			}
			//返回模块管理器单体对象
			return this;
		}

		// F.string模块   标记
		F.define(string ', function(){
			//接口方法
			return {
				//清楚字符串两边空白
				trim: function(str) {
					return str.replace( ^ \s + | \s + $ / g, ");
					}
				}
			});
	</script>

</html>